Magic-link auth is absolutely the right “first bite.”
Once it’s in place the rest of the lean refactor can build on a solid, simplified login flow.

Below is a **concrete implementation plan** (with file-level pointers and code skeletons) that an AI/you can follow top-to-bottom. If it looks good, tell me *“Ship it”* and I’ll generate the actual code + migrations in the next turn.

---

## 0.  Prep

| What          | Details                                                                                       |
| ------------- | --------------------------------------------------------------------------------------------- |
| **Env var**   | `MAGIC_TOKEN_SECRET=<32+ random bytes>` – used to HMAC-SHA256 the raw token before DB insert. |
| **Constants** | `MAGIC_TOKEN_TTL_MIN = 15` (expires in 15 min).                                               |
| **Dev URL**   | assume `http://localhost:5173`.                                                               |

---

## 1.  Database (Drizzle)

### 1 a.  Migration file `000X_magic_tokens.sql`

```sql
CREATE TABLE login_tokens (
  token_hash  CHAR(64) PRIMARY KEY,
  user_id     INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  expires_at  TIMESTAMPTZ NOT NULL,
  consumed_at TIMESTAMPTZ,
  ip_fingerprint TEXT
);
CREATE INDEX login_tokens_user_idx ON login_tokens(user_id);
```

### 1 b.  Drizzle model `shared/schema.ts`

```ts
export const loginTokens = pgTable("login_tokens", {
  tokenHash: char("token_hash", { length: 64 }).primaryKey(),
  userId:    integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  expiresAt: timestamp("expires_at", { withTimezone: true }).notNull(),
  consumedAt: timestamp("consumed_at", { withTimezone: true }),
  ipFingerprint: text("ip_fingerprint"),
});
```

`drizzle-kit push` will create the TS migration automatically.

---

## 2.  Repository helpers (`server/storage.ts`)

```ts
export async function storeLoginToken(tx, { tokenHash, userId, expiresAt, ipFp }) {
  await tx.insert(loginTokens).values({ tokenHash, userId, expiresAt, ipFingerprint: ipFp });
}

export async function getValidLoginToken(tokenHash) {
  return db.select().from(loginTokens)
    .where(and(
      eq(loginTokens.tokenHash, tokenHash),
      isNull(loginTokens.consumedAt),
      gt(loginTokens.expiresAt, sql`now()`)
    ))
    .limit(1)
    .then(r => r[0]);
}

export async function consumeLoginToken(tx, tokenHash) {
  await tx.update(loginTokens)
    .set({ consumedAt: sql`now()` })
    .where(eq(loginTokens.tokenHash, tokenHash));
}
```

---

## 3.  Auth Service (`server/services/authService.ts`)

```ts
import crypto from "crypto";
import { storeLoginToken, getValidLoginToken, consumeLoginToken } from "../storage";
import { createJwt } from "../lib/auth";

function hash(raw: string) {
  return crypto.createHmac("sha256", process.env.MAGIC_TOKEN_SECRET!).update(raw).digest("hex");
}

export async function requestLogin(email: string, ip: string, ua: string) {
  let user = await getUserByEmail(email);
  if (!user) {
    // auto-create parent
    user = await createParentUser({ email, name: email.split("@")[0] });
  }

  const rawToken = crypto.randomBytes(48).toString("hex");
  const tokenHash = hash(rawToken);
  const expiresAt = new Date(Date.now() + MAGIC_TOKEN_TTL_MIN * 60_000);
  const ipFp = crypto.createHash("sha256").update(ip + ua.slice(0, 80)).digest("hex");

  await storeLoginToken(db, { tokenHash, userId: user.id, expiresAt, ipFp });

  const magicLink = `${process.env.APP_URL ?? "http://localhost:5173"}/login-consume?token=${rawToken}`;
  if (process.env.NODE_ENV === "development") {
    console.log("🔑  Magic link:", magicLink);
  } else {
    await sendEmail({ to: email, subject: "Your TicketTracker login link", text: magicLink });
  }
}

export async function consumeLogin(rawToken: string, ip: string, ua: string) {
  const tokenHash = hash(rawToken);
  const token = await getValidLoginToken(tokenHash);
  if (!token) throw new Error("Invalid or expired link");

  const ipFp = crypto.createHash("sha256").update(ip + ua.slice(0, 80)).digest("hex");
  if (token.ipFingerprint && token.ipFingerprint !== ipFp) throw new Error("IP/UA mismatch");

  await consumeLoginToken(db, tokenHash);

  const user = await getUserById(token.userId);
  const jwt = createJwt({ userId: user.id, role: user.role });

  return { jwt, user };
}
```

---

## 4.  Routes (`server/routes.ts`)

```ts
router.post("/api/v1/auth/request-login", async (req, res) => {
  const { email } = req.body;
  await requestLogin(email, req.ip, req.headers["user-agent"] ?? "");
  res.status(202).json({ ok: true });  // always 202 to avoid email enumeration
});

router.post("/api/v1/auth/consume-login", async (req, res) => {
  const { token } = req.body;
  try {
    const { jwt, user } = await consumeLogin(token, req.ip, req.headers["user-agent"] ?? "");
    res.json({ token: jwt, user });
  } catch {
    res.status(401).json({ message: "Invalid or expired link" });
  }
});
```

JWT middleware elsewhere stays unchanged.

---

## 5.  Front-end

### 5 a.  Page: `LoginRequest.tsx`

```tsx
export default function LoginRequest() {
  const [email, setEmail] = useState("");
  const [sent, setSent] = useState(false);

  const handleSend = async () => {
    await api.post("/api/v1/auth/request-login", { email });
    setSent(true);
  };

  return sent ? (
    <div className="p-6 text-center">📬 Check your inbox (or dev console) for the link.</div>
  ) : (
    <Card className="max-w-sm mx-auto mt-20 p-6">
      <Input placeholder="parent@email.com" value={email} onChange={e => setEmail(e.target.value)} />
      <Button className="mt-4 w-full" onClick={handleSend} disabled={!email}>
        Send login link
      </Button>
    </Card>
  );
}
```

### 5 b.  Page: `LoginConsume.tsx`

```tsx
export default function LoginConsume() {
  const token = new URLSearchParams(location.search).get("token");
  const navigate = useNavigate();
  useEffect(() => {
    (async () => {
      try {
        const { data } = await api.post("/api/v1/auth/consume-login", { token });
        localStorage.setItem("jwt", data.token);                      // TODO: move to HttpOnly cookie
        authStore.login(data.token, data.user);
        navigate("/");
      } catch {
        toast.error("Link expired or invalid. Request a new one.");
        navigate("/login");
      }
    })();
  }, [token]);

  return <div className="p-6 text-center">🔄 Signing you in…</div>;
}
```

Add both pages to the router.

---

## 6.  Post-install sanity script

```bash
pnpm drizzle-kit push        # applies migration
pnpm dev                     # backend
pnpm web                     # frontend
# In browser: go to /login, enter parent email -> check server console for link
```

---

### Optional Fast-follow

* **Seed script** that inserts the parent + Bryce + Kiki users on first run (skip if you’ll create them manually).
* **IP fingerprint** check can be toggled off in `.env.development`.

---

Does this blueprint look good?
➡️ **Reply “Ship it”** and I’ll generate the actual code/migration files. If you want tweaks first, just let me know!
